{"/home/travis/build/npmtest/node-npmtest-monitor-dashboard/test.js":"/* istanbul instrument in package npmtest_monitor_dashboard */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/lib.npmtest_monitor_dashboard.js":"/* istanbul instrument in package npmtest_monitor_dashboard */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_monitor_dashboard = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_monitor_dashboard = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-monitor-dashboard && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_monitor_dashboard */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_monitor_dashboard\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_monitor_dashboard.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_monitor_dashboard.rollup.js'] =\n            local.assetsDict['/assets.npmtest_monitor_dashboard.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_monitor_dashboard.__dirname + '/lib.npmtest_monitor_dashboard.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/monitor.js":"// monitor.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Load dependencies\n  var Monitor = require('./lib/index'),\n      Server = Monitor.Server,\n      UI = Monitor.UI,\n      UIServer = UI.Server,\n      OS = require('os');\n\n  /**\n  * Entry point into the monitor UI server application\n  *\n  * This is the module loaded and run by Node.js on program start.\n  * It bootstraps the node.js dashboard server.\n  */\n\n  // Display the logo\n  console.log(\"\");\n  console.log(\"             _________                                  __________\");\n  console.log(\"___________________  /____      _______ ___________________(_)_  /______________\");\n  console.log(\"__  __ \\\\  __ \\\\  __  /_  _ \\\\     __  __ `__ \\\\  __ \\\\_  __ \\\\_  /_  __/  __ \\\\_  ___/\");\n  console.log(\"_  / / / /_/ / /_/ / /  __/     _  / / / / / /_/ /  / / /  / / /_ / /_/ /  /\");\n  console.log(\"/_/ /_/\\\\____/\\\\__,_/  \\\\___/      /_/ /_/ /_/\\\\____//_/ /_//_/  \\\\__/ \\\\____//_/\");\n  console.log(\"\");\n\n  // Output an application template\n  if (process.argv.length > 3 && process.argv[2] === '--app') {\n    require('./lib/js/AppTemplate');\n    process.exit(0);\n  }\n\n  // Boot the UI server.\n  // This accepts http and websocket connections on the configured port.\n  var uiServer = new UIServer();\n  uiServer.start(function() {\n    // If the host can connect from any IP address (INADDR_ANY), display the DNS hostname\n    var connectTo = Monitor.Config.Dashboard.allowExternalConnections ? OS.hostname() : 'localhost';\n    console.log(\"Now showing at http://\" + connectTo + \":\" + uiServer.get('port') + \"/\");\n\n    // Output security concerns\n    if (!Monitor.Config.Dashboard.allowExternalConnections) {\n      console.log(\"\");\n      console.log(\"External connections disabled.\");\n      console.log(\"See \" + process.cwd() + \"/config/external.js for more information.\");\n    }\n  });\n\n  // Boot another Monitor server for accepting websocket connections\n  // on the standard Monitor port range.\n  var server = new Server();\n  server.start();\n\n  // Process uncaught exceptions.\n  process.on('uncaughtException', function(err){\n\n    // On laptop sleep/startup the DNS servers aren't immediately available,\n    // resulting in a flood of these for socket.io until DNS services are back up.\n    if (err.message === 'ECONNREFUSED, Could not contact DNS servers') {\n      return;\n    }\n\n    // Don't allow the process to continue in an unknown state.\n    console.error(\"Uncaught Exception: \" + err.message);\n    console.error(err.stack);\n    uiServer.stop(function(){\n      process.exit(1);\n    });\n\n    // Don't wait around if the server is hung.\n    setTimeout(function(){process.exit(1);}, 2000);\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/index.js":"// index.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  /*\n  * Entry point for commonJS style loading\n  *\n  * This file coordinates the loading of modules in a consistent order\n  * in a commonJS environment.\n  */\n\n  var commonJS = (typeof exports !== 'undefined');\n  if (commonJS) {\n\n    // Grunt.js contains the module definition files\n    var MODULE_DEF = require('../grunt.js').MODULE_DEF;\n\n    // Load external commonJS modules\n    var Monitor = module.exports = require('monitor');\n\n    // Attach backbone callbacks\n    require('backbone-callbacks').attach(Monitor.Backbone);\n\n    // Load all files so they have a consistent loading order\n    var allFiles = MODULE_DEF.shared_js.concat(MODULE_DEF.server_js);\n    allFiles.forEach(function(file) {\n      require('../' + file);\n    });\n  }\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/grunt.js":"// grunt.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For all details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n\nvar exec = require('child_process').exec;\n\n// This is used in the build automation tasks, and on the server\n// when running in dev mode to serve individual files for debugging.\nvar MODULE_DEF = {\n  shared_js: [\n    \"lib/js/UI.js\",\n    \"lib/js/Template.js\",\n    \"lib/js/Site.js\",\n    \"lib/js/Component.js\",\n    \"lib/js/Page.js\",\n    \"lib/js/Tree.js\",\n    \"lib/js/Tour.js\"\n  ],\n  server_js: [\n    \"lib/js/NetworkMap.js\",\n    \"lib/js/Server.js\",\n    \"lib/js/TreeProbe.js\",\n    \"lib/js/PagesProbe.js\",\n    \"lib/js/ToursProbe.js\"\n  ],\n  client_js: [\n    \"lib/js/IconChooser.js\",\n    \"lib/js/DropDownMenu.js\",\n    \"lib/js/JsonView.js\",\n    \"lib/js/TreeView.js\",\n    \"lib/js/MonitorPicker.js\",\n    \"lib/js/SettingsView.js\",\n    \"lib/js/NewComponentView.js\",\n    \"lib/js/ComponentSettingsView.js\",\n    \"lib/js/ComponentView.js\",\n    \"lib/js/PageSettingsView.js\",\n    \"lib/js/PageView.js\",\n    \"lib/js/Sidebar.js\",\n    \"lib/js/SidebarView.js\",\n    \"lib/js/TourView.js\",\n    \"lib/js/TourSettingsView.js\"\n  ],\n  templates: [\n    \"lib/template/UI.html\",\n    \"lib/template/PageView.html\",\n    \"lib/template/PageSettings.html\",\n    \"lib/template/PageCopy.html\",\n    \"lib/template/SidebarView.html\",\n    \"lib/template/TourView.html\",\n    \"lib/template/TourSettings.html\",\n    \"lib/template/ComponentView.html\",\n    \"lib/template/ComponentSettings.html\",\n    \"lib/template/NewComponentView.html\",\n    \"lib/template/NewPage.html\",\n    \"lib/template/NewTourPage.html\",\n    \"lib/template/ComponentIcon.html\"\n  ],\n  client_css: [\n    \"lib/css/default/bootstrap.min.css\",\n    \"lib/css/default/font-awesome.css\",\n    \"lib/css/default/UI.css\",\n    \"lib/css/default/MonitorPicker.css\",\n    \"lib/css/default/ComponentView.css\",\n    \"lib/css/default/ComponentSettings.css\",\n    \"lib/css/default/NewComponentView.css\",\n    \"lib/css/default/DropDownMenu.css\",\n    \"lib/css/default/PageView.css\",\n    \"lib/css/default/PageSettings.css\",\n    \"lib/css/default/SidebarView.css\",\n    \"lib/css/default/TourView.css\",\n    \"lib/css/default/TourSettings.css\",\n    \"lib/css/default/JsonView.css\",\n    \"lib/css/default/TreeView.css\",\n    \"lib/ext/jquery.miniColors.css\"\n  ],\n  client_ext: [\n    \"lib/ext/jquery-1.8.2.min.js\",\n    \"lib/ext/monitor-all.js\",\n    \"lib/ext/Backbone.ModelBinder.min.js\",\n    \"lib/ext/bootstrap.min.js\",\n    \"lib/ext/bootstrap-tooltip.js\",\n    \"lib/ext/bootstrap-dropdown.js\",\n    \"lib/ext/bootstrap-modal.js\",\n    \"lib/ext/bootstrap-alert.js\",\n    \"lib/ext/mustache-0.7.0-dev.js\",\n    \"lib/ext/numeral.min.js\",\n    \"lib/ext/jquery.miniColors.min.js\"\n  ]\n};\n\n// Build automation tasks\nmodule.exports = function(grunt) {\n\n  // Project configuration.\n  grunt.initConfig({\n    pkg: '<json:package.json>',\n    module: MODULE_DEF,\n    lint: {\n      files: ['grunt.js', '<config:module.server_js>', '<config:module.client_js>', 'test/**/*.js']\n    },\n    test: {\n      files: ['test/**/*.js']\n    },\n    watch: {\n      files: ['grunt.js', '<config:module.server_js>', '<config:module.client_js>', 'test/**/*.js'],\n      tasks: 'default'\n    },\n    min: {\n      ui: {\n        src: ['<config:monitor.lib>', '<config.monitor.ui>'],\n        dest: '/tmp/monitor-base-min.js'\n      },\n      css: {\n        src: ['ui/client/css/all.css'],\n        dest: 'ui/client/css/all.min.css'\n      }\n    },\n    concat: {\n      ui: {\n        src: ['<config:monitor.ext>', '/tmp/monitor-base-min.js'],\n        dest: 'ui/client/src/monitor-min.js'\n      },\n      css: {\n        src: ['<config:monitor.css>'],\n        dest: 'ui/client/css/all.css'\n      }\n    },\n    jshint: {\n      options: {\n        strict: false,\n        curly: true,\n        eqeqeq: true,\n        immed: true,\n        latedef: true,\n        newcap: true,\n        noarg: true,\n        sub: true,\n        undef: true,\n        boss: true,\n        eqnull: true,\n        node: true\n      },\n      globals: {\n        exports: true\n      }\n    }\n  });\n\n  grunt.registerTask('doc', 'Generate documentation files', function() {\n    var t = this, done = t.async(), child;\n    child = exec('yuidoc -c ./yuidoc.json', function (error, stdout, stderr) {\n      console.log(stderr);\n      console.log(stdout);\n      done();\n    });\n  });\n\n  // Default task.\n  grunt.registerTask('default', 'doc lint test');\n  grunt.registerTask('dist', 'min:ui concat:ui concat:css');\n\n};\n\n// Expose externally\nmodule.exports.MODULE_DEF = MODULE_DEF;\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/UI.js":"/*global window document $ localStorage alert*/\n\n// UI.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      OS = Monitor.commonJS ? require('os') : null,\n      Backbone = Monitor.Backbone,\n      _ = Monitor._,\n      templates = {};  // Cache key=app-name, value=Template object\n\n  // Constants\n  var KEY_ESC = 27;\n\n  /**\n  * Node Monitor Namespace\n  *\n  * This class is here to provide a global namespace to attach all UI classes\n  * and UI utility functions.\n  *\n  * @static\n  * @class UI\n  * @constructor\n  */\n  var UI = Monitor.UI = function(){};\n  var Mustache = UI.Mustache = Monitor.commonJS ? require('../ext/mustache-0.7.0-dev.js') : root.Mustache;\n\n  /**\n  * Load the specified template\n  *\n  * This loads the template from cache, from the DOM (if present), or from the\n  * server if it's not in DOM.\n  *\n  * It can be run on the client side only\n  *\n  * @static\n  * @method loadTemplate\n  * @param app {String} Application name\n  * @param name {String} Template name\n  * @param callback {Function(error, template)} Called when the template is loaded or on error.\n  *     @param callback.error {Object} Object containing the error or null if no error\n  *     @param callback.template {Template} The Template object\n  */\n  UI.loadTemplate = function(app, name, callback) {\n\n    // See if the template is in cache\n    var cacheKey = app ? app + '-' + name : name;\n    if (templates[cacheKey]) {\n      return callback(null, templates[cacheKey]);\n    }\n\n    // See if the template is in DOM\n    var domId = '#nm-template-' + cacheKey;\n    if ($(domId).length) {\n      return callback(null, templates[cacheKey] = new UI.Template({\n        text: $(domId).html()\n      }));\n    }\n\n    // Get the template from the server\n    var url = (app ? '/app/' + app : '/static') + '/template/' + name + '.html';\n    $.get(url, function(data){\n      // If we have a <doctype>, then we've gotten a 404\n      if (data.indexOf('<!DOCTYPE html>') === 0) {\n        return callback({code:'ENOENT', msg:'No template found at ' + url});\n      }\n      templates[cacheKey] = new UI.Template({text:data});\n      return callback(null, templates[cacheKey]);\n    }, 'html').error(callback);\n  };\n\n  /**\n  * Static Configurations\n  *\n  * These can be set onto the UI class after it's loaded, or via the\n  * node.js config package if running server-side.\n  *\n  * @static\n  * @property Config\n  * @type &lt;Object&gt;</code>\n  * <ul>\n  * </ul>\n  */\n  var defaultConfig = {\n    port: 4200,\n    allowExternalConnections: false,\n    siteDbPath: './site_db'\n  };\n  if (Monitor.commonJS) {\n    Monitor.Config.setModuleDefaults('Dashboard', defaultConfig);\n  } else {\n    _.extend(Monitor.Config, {Monitor: defaultConfig});\n  }\n  UI.Config = Monitor.Config.Monitor;\n\n  // Create the app namespace\n  var app = UI.app = {};\n\n  // Expose jquery if on the client.  No longer needed on the server.\n  var $ = UI.$ = root.$ || {fn:{}};\n\n  /* jQuery no longer needed on the server\n  // Set up server-side jQuery\n  $.support.cors = true;\n  if (Monitor.commonJS) {\n    var XHR = require('xmlhttprequest').XMLHttpRequest;\n    $.ajaxSetup({xhr: function(){return new XHR();}});\n  }\n  */\n\n  // A generic mask to use for modals.  Can be stacked for modal within modal\n  // (example: dropdown within a dialog).\n  UI.ModalMask = Backbone.View.extend({\n    initialize: function(options){\n      var t = this;\n\n      // Render on new\n      t.$el.addClass('nm-mask').appendTo('body');\n\n      // Attaching keydown to the document vs. the view\n      t.keydown = t.onKeyDown.bind(t);\n      $(document).on('keydown', t.keydown);\n\n    },\n    events: {\n      'click'   : 'close'\n    },\n    onKeyDown: function(e) {\n      var t = this;\n      if (e.keyCode === KEY_ESC) {\n        return t.close(e);\n      }\n    },\n    close: function(e) {\n      var t = this;\n      t.trigger('close');\n      t.$el.remove();\n      $(document).off('keydown', t.keydown);\n      e.stopPropagation();\n      e.preventDefault();\n      return false;\n    }\n  });\n\n  // Common dialog box move logic\n  UI.modalDragStart = function(e) {\n    var dialog = $(e.currentTarget).parent(),\n        zoomRatio = window.innerWidth / window.outerWidth,\n        newPosition = {\n          top: parseInt(dialog.css('top'), 10) * zoomRatio,\n          left: parseInt(dialog.css('left'), 10) * zoomRatio\n        },\n        offset = {\n          top: e.pageY - newPosition.top,\n          left: e.pageX - newPosition.left\n        };\n\n    function drag(e) {\n      newPosition.top = Math.max(e.pageY - offset.top, 0);\n      newPosition.left = Math.max(e.pageX - offset.left, 0);\n      dialog.css(newPosition);\n    }\n    function drop(e) {\n      dialog.addClass('fade');\n      $(document).unbind(\"mousemove\", drag).unbind(\"mouseup\", drop);\n    }\n    $(document).bind(\"mousemove\", drag).bind(\"mouseup\", drop);\n    dialog.removeClass('fade');\n    drag(e);\n    e.preventDefault();\n  };\n\n  /**\n  * Merge changes from another array or collection\n  *\n  * This adds a ```set()``` method to Backbone.Collection, which merges the\n  * specified array or collection into the existing collection.\n  *\n  * It is useful for streaming updates into existing collections without\n  * disrupting any event listeners attached to existing models.\n  *\n  * If an item already exists, it merges changes into it.  If an item\n  * doesn't exist it adds it, and it removes any item in the collection that\n  * isn't in the array or collection passed in to the method.\n  *\n  * Example:\n  *\n  *     var stream = JSON.stringify(myCollection);\n  *     var myArray = JSON.parse(stream);\n  *     myArray[0].lastUpdated = new Date();\n  *     myCollection.set(myArray);\n  *\n  * @method Backbone.Collection.set\n  * @param items {Array or Backbone.Collection} The items to set into the collection\n  * @param options {Object} Set options to pass to individual model create/set\n  */\n  Backbone.Collection.prototype.set = function(items, options) {\n\n    var t = this,\n        prevModels = t.models,\n        newIds = items.pluck ? items.pluck('id') : _.pluck(items, 'id'),\n        i, len, id, cid, prevModel, newItem, removeIds = [], newIdHash = {};\n\n    // Merge or add items to this collection\n    for (i = 0, len = newIds.length; i < len; i++) {\n      id = newIds[i];\n      newItem = items[i];\n      newIdHash[id] = true;\n      prevModel = t.get(id);\n      if (prevModel) {\n        prevModel.set(newItem instanceof Backbone.Model ? newItem.attributes : newItem, options);\n      } else {\n        t.add(newItem, options);\n      }\n    }\n\n    // Remove any item not in new items\n    t.each(function(model) {\n      id = model.get('id');\n      if (!newIdHash[id]) {\n        removeIds.push(id);\n      }\n    });\n    t.remove(removeIds);\n  };\n\n  /**\n  * Set up a contained model or contained collection relationship\n  *\n  * This is called during initialize of a parent backbone model that contains\n  * another backbone model or collection.  It:\n  *\n  *     * Creates the correct model if setting from a non-model object\n  *     * Merges changes on set vs. overwriting the existing contained object\n  *     * Merges collection items vs. replacing (if it's a collection)\n  *     * Alters toJSON to return the contained object toJSON vs. the object reference\n  *\n  * Example:\n  *\n  *     UI.containedModel(this, 'author', Author);\n  *\n  * @method containedModel\n  * @param model {Backbone.Model} The parent model object\n  * @param attrName {String} Name of the attribute that contains the model or collection\n  * @param Ctor {Function} The constructor function of the contained model or collection\n  */\n  UI.containedModel = function(model, attrName, Ctor) {\n\n    // Build the function for setting model data\n    function setAttr(setModel, newValue, setOptions) {\n      var oldValue = model._containedModels[attrName];\n\n      // Pass through if removing\n      if (newValue === undefined || newValue === null) {\n        model._containedModels[attrName] = newValue;\n        return;\n      }\n\n      // Is the new value the correct type?\n      if (newValue instanceof Ctor) {\n\n        // Directly set if no old value\n        if (!oldValue instanceof Ctor) {\n          model._containedModels[attrName] = newValue;\n          return;\n        }\n\n        // They're both models.  Disregard if they're the same.\n        var oldJSON = oldValue.toJSON({deep:true});\n        var newJSON = newValue.toJSON({deep:true});\n        if (_.isEqual(oldJSON, newJSON)) {\n          return;\n        }\n\n        // Merge the raw JSON if they're both models\n        newValue = newJSON;\n      }\n\n      // Keep the previous model and merge new data into it\n      // For collections this relies on the Collection.set() method\n      if (oldValue instanceof Ctor) {\n        model.attributes[attrName] = oldValue;\n        model._currentAttributes[attrName] = oldValue;\n        model.changed[attrName] = oldValue;\n        oldValue.set(newValue, setOptions);\n        return;\n      }\n\n      // Create a new model or collection, passing the value\n      newValue =\n        model._containedModels[attrName] =\n        model.attributes[attrName] =\n        model._currentAttributes[attrName] =\n        new Ctor(newValue, setOptions);\n\n      // Watch for changes to the underlying model or collection\n      // (collection add/remove), forwarding changes to this model\n      newValue.on('change add remove reset', UI.onSubModelChange, {\n        parent:model,\n        attrName: attrName\n      });\n    }\n\n    // Remember the contained models before they're overridden by set\n    if (!model._containedModels) {\n      model._containedModels = {};\n    }\n\n    // Watch for changes to the underlying model or collection\n    // (collection add/remove), forwarding changes to this model\n    var subModel = model.get(attrName);\n    if (subModel instanceof Backbone.Model || subModel instanceof Backbone.Collection) {\n      subModel.on('change add remove reset', UI.onSubModelChange, {\n        parent:model,\n        attrName: attrName\n      });\n    }\n\n    // Set the initial model data\n    setAttr(model, model.get(attrName));\n\n    // Watch for subsequent changes\n    model.on('change:' + attrName, setAttr, model);\n  };\n\n  /**\n  * Change listener attached to contained models - for bubbling change\n  * events to the containing model.\n  *\n  * @method onSubModelChange\n  * @param model {Model} Backbone model changed\n  * @param [collection] {Backbone collection} if a collection add/remove\n  * @param options {Object} Event options\n  * @param this {Object} 'this' is a custom object containing:\n  *     @param this.parent {Backbone.Model} Parent container for this object\n  *     @param this.attrName {String} Parents attribute name for this model\n  */\n  UI.onSubModelChange = function(model) {\n    var t = this,\n        parent = t.parent,\n        attrName = t.attrName,\n        // Options is arg[2] for add/remove and arg[1] for change\n        chgOptions = arguments[2] || arguments[1] || {};\n\n    // If the parent isn't currently changing, the source of the change\n    // came from the contained model.  Trigger changes to the parent model.\n    if (!chgOptions.silent && !parent._changing) {\n\n      // Use setTimeout to bundle up all changes into a single change event\n      // for each attribute and the parent class.\n      parent._pendingChanges = parent._pendingChanges || {};\n      parent._pendingChanges[attrName] = true;\n      if (!parent._subModelTimer) {\n\n        // Create one timer for all changes to the parent\n        parent._subModelTimer = setTimeout(function(){\n          var changes = {};\n          for (var chgAttrName in parent._pendingChanges) {\n\n            // Get the changed attribute for the set\n            changes[chgAttrName] = parent.attributes[chgAttrName];\n\n            // Make sure a change is detected\n            parent.attributes[chgAttrName] = '';\n            parent._currentAttributes[chgAttrName] = '';\n            parent._previousAttributes[chgAttrName] = '';\n          }\n\n          // Set all sub-model changes into the parent\n          parent.set(changes);\n\n          // Remove our internal members\n          delete parent._pendingChanges;\n          delete parent._subModelTimer;\n        },0);\n      }\n    } else {\n\n      // Inform the parent that this attribute has pending changes.\n      // This is necessary for the parent to fire it's own change event.\n      parent._pending[attrName] = true;\n    }\n  };\n\n  /**\n  * Additional options for the Backbone.js toJSON method\n  *\n  * If the options hash contains {deep:true}, then call the toJSON() method of\n  * any contained objects that have a toJSON method.\n  *\n  * If the options hash contains {trim:true}, then only output values that\n  * differ from the default value.  This produces a less chatty JSON string,\n  * useful for for streaming models across the wire.\n  *\n  * @method toJSON\n  * @return {Object} A raw JS copy of the data model\n  */\n  Backbone.Model.prototype.toJSON = function(options) {\n    var t = this,\n        result = {},\n        defaults = _.isFunction(t.defaults) ? t.defaults() : t.defaults,\n        attrs = t.attributes,\n        attr, value;\n\n    options = options || {};\n\n    for (attr in attrs) {\n      value = attrs[attr];\n      if (options.deep && value && _.isFunction(value.toJSON)) {\n        value = value.toJSON(options);\n      }\n      if (options.trim && defaults) {\n        if (!_.isEqual(value, defaults[attr])) {\n          result[attr] = value;\n        }\n      } else {\n        result[attr] = value;\n      }\n    }\n    return result;\n  };\n\n  /**\n  * Attach a common tooltip to the specified selector\n  *\n  * This attaches a bootstrap.js tooltip onto the elements specified with\n  * the jQuery selector.  It adds classes to the tooltip elements, allowing them\n  * to be individually styled.\n  *\n  * @method tooltip\n  * @param selector {jQuery Selector} Selector of items to add tooltips onto\n  * @param options {Object} Tool tip options\n  */\n  UI.tooltip = function(selector, options) {\n    selector.addClass('nm-pv-tt').tooltip(_.extend({\n      placement: 'left',\n      template: '<div class=\"tooltip nm-pv-tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n      delay: {show: 500, hide:10}\n    }, options));\n  };\n\n  /**\n  * Hide all tooltips and cancel awaiting timers\n  *\n  * @method hideToolTips\n  */\n  UI.hideToolTips = function() {\n    $('.nm-pv-tt').each(function() {\n      var $el = $(this),\n          tooltip = $el.data('tooltip');\n      if (tooltip) {\n        clearTimeout($el.data('tooltip').timeout);\n      }\n      $el.tooltip('hide');\n    });\n  };\n\n  /**\n  * Pause the tour if running\n  */\n  UI.pauseTour = function() {\n    if (UI.pageView.tourView) {\n      UI.pageView.tourView.pause();\n    }\n  };\n\n  /**\n  * jQuery add-on for inserting CSS into the DOM\n  *\n  * This method can accept a CSS style sheet in a string, an array of strings,\n  * or an object with keys representing selectors and values representing styles.\n  *\n  * String example:\n  *\n  *     $.styleSheet(\"body: {background:white;}\");\n  *\n  * Array example:\n  *\n  *     $.styleSheet([\n  *       \"body: {background:white;}\",\n  *       \"#canvas: background: #e0e0e0; max-width: 400px;\"\n  *     ]);\n  *\n  * Object example:\n  *\n  *     $.styleSheet({\n  *       \"body\"    : \"background: white;\",\n  *       \"#canvas\" : \"background: #e0e0e0; max-width: 400px;\"\n  *     });\n  *\n  * Deep object example:\n  *\n  *     $.styleSheet({\n  *       \"body\": {\n  *         \"background\": \"white\",\n  *       },\n  *       \"#canvas\":\n  *         \"background\": \"#e0e0e0\",\n  *         \"max-width\": \"400px\";\"\n  *     });\n  *\n  * @static\n  * method $.styleSheet\n  * @param styles {String, Array, or Object} Styles to apply to the page\n  * @param id {String} ID of the style element.  This places an ID attribute onto the style tag, and replaces any prior style element with the specified ID.\n  */\n  $.styleSheet = function(styles, id) {\n\n    // Build the style string based on the input type\n    var styleStr = '', idAttr = '';\n    if (typeof styles === 'string') {\n      styleStr = styles;\n    }\n    else if (Array.isArray(styles)) {\n      styleStr = styles.join('\\n');\n    }\n    else if (typeof styles === 'object') {\n      for (var selector in styles) {\n        var value = styles[selector], valueStr = '';\n        if (typeof value === 'string') {\n          valueStr = value;\n        }\n        else if (typeof value === 'object') {\n          for (var cssAttr in value) {\n            valueStr += cssAttr + ':' + value[cssAttr] + \"; \";\n          }\n        }\n        styleStr += selector + \"{\" + valueStr + \"} \";\n      }\n    }\n\n    // Remove any prior style with the specified ID\n    if (id) {\n      $('#' + id).remove();\n      idAttr = 'id=\"' + id + '\" ';\n    }\n\n    // Insert into DOM\n    if (styleStr) {\n      $('<style ' + idAttr + 'type=\"text/css\">' + styleStr + '</style>').appendTo('head');\n    }\n  };\n\n  /**\n  * jQuery utility for centering a div on the screen\n  *\n  * @static\n  * @method $.centerBox\n  */\n  $.fn.centerBox = function () {\n    var t = this;\n    t.css(\"top\", Math.max(0, (($(window).height() - this.outerHeight()) / 2) + $(window).scrollTop()) + \"px\");\n    t.css(\"left\", Math.max(0, (($(window).width() - this.outerWidth()) / 2) + $(window).scrollLeft()) + \"px\");\n    return t;\n  };\n\n  /**\n  * jQuery utility for converting a style string into an object\n  *\n  * This converts a string like this:\n  *\n  *     var style = \"top:15px; left:200px; background-color:#202020\";\n  *\n  * Into an object like this:\n  *\n  *     {\n  *       \"top\": \"15px\",\n  *       \"left\": \"200px\",\n  *       \"background-color\": \"#202020\"\n  *     }\n  *\n  * @static\n  * method $.parseStyleString\n  * @param styleString {String} CSS Style string\n  * @return {Object} The parsed styles, as an object\n  */\n  $.parseStyleString = function(styleString) {\n    var parsed = {}, parts = styleString.split(';');\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var nameVal = parts[i].split(':');\n      if (nameVal.length === 2) {\n        parsed[nameVal[0].trim()] = nameVal[1].trim();\n      }\n    }\n    return parsed;\n  };\n\n  /**\n  * jQuery utility for converting a CSS object into a style string\n  *\n  * This converts an object like this:\n  *\n  *     var css = {\n  *       \"top\": \"15px\",\n  *       \"left\": \"200px\",\n  *       \"background-color\": \"#202020\"\n  *     }\n  *\n  * Into a string like this:\n  *\n  *     \"top:15px; left:200px; background-color:#202020;\"\n  *\n  * @static\n  * method $.makeStyleString\n  * @param css {Object} The CSS object\n  * @return {String} The style string\n  */\n  $.makeStyleString = function(css) {\n    var styles = '', separator = '';\n    for (var elemName in css) {\n      styles += separator + elemName + \":\" + css[elemName] + ';';\n      separator = ' ';\n    }\n    return styles;\n  };\n\n  /**\n  * jQuery utility for making a string Title Case\n  *\n  * @static\n  * method $.titleCase\n  * @param titleString {String} A title string\n  * @param preserveCase {String} Don't lowercase the string first\n  * @return {String} The titleString Title Cased\n  */\n  $.titleCase = function(titleString, preserveCase) {\n    var newTitle = preserveCase ? titleString : titleString.toLowerCase();\n    newTitle = newTitle.split(' ');\n    for (var i = 0, l = newTitle.length; i < l; i++) {\n      newTitle[i] = newTitle[i].substr(0,1).toUpperCase() + newTitle[i].substr(1);\n    }\n    return newTitle.join(' ');\n  };\n\n  // Add Function.bind to browsers that don't support it yet (mobile safari & ie).\n  // Thanks to https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n      if (typeof this !== \"function\") {\n        // closest thing possible to the ECMAScript 5 internal IsCallable function\n        throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n      }\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        FNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n      FNOP.prototype = this.prototype;\n      fBound.prototype = new FNOP();\n      return fBound;\n    };\n  }\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/ext/mustache-0.7.0-dev.js":"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\nvar Mustache;\n\n(function (exports) {\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = exports; // CommonJS\n  } else if (typeof define === \"function\") {\n    define(exports); // AMD\n  } else {\n    Mustache = exports; // <script>\n  }\n}((function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.0\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      return value.call(context.view, text, scopedRender) || \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Calculates the bounds of the section represented by the given `token` in\n   * the original template by drilling down into nested sections to find the\n   * last token that is part of that section. Returns an array of [start, end].\n   */\n  function sectionBounds(token) {\n    var start = token[3];\n    var end = start;\n\n    var tokens;\n    while ((tokens = token[4]) && tokens.length) {\n      token = tokens[tokens.length - 1];\n      end = token[3];\n    }\n\n    return [start, end];\n  }\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice.apply(template, sectionBounds(token));\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have a fifth item: an array that contains\n   * all tokens in that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case \"#\":\n      case \"^\":\n        token[4] = [];\n        sections.push(token);\n        collector.push(token);\n        collector = token[4];\n        break;\n      case \"/\":\n        if (sections.length === 0) {\n          throw new Error(\"Unopened section: \" + token[1]);\n        }\n\n        section = sections.pop();\n\n        if (section[1] !== token[1]) {\n          throw new Error(\"Unclosed section: \" + section[1]);\n        }\n\n        if (sections.length > 0) {\n          collector = sections[sections.length - 1][4];\n        } else {\n          collector = tree;\n        }\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    // Make sure there were no open sections when we're done.\n    section = sections.pop();\n\n    if (section) {\n      throw new Error(\"Unclosed section: \" + section[1]);\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var token, lastToken;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      if (lastToken && lastToken[0] === \"text\" && token[0] === \"text\") {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n        tokens.splice(i--, 1); // Remove this token from the array.\n      } else {\n        lastToken = token;\n      }\n    }\n  }\n\n  function escapeTags(tags) {\n    if (tags.length !== 2) {\n      throw new Error(\"Invalid tags: \" + tags.join(\" \"));\n    }\n\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    tags = tags || exports.tags;\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var tokens = [],      // Buffer to hold the tokens\n        spaces = [],      // Indices of whitespace tokens on the current line\n        hasTag = false,   // Is there a {{tag}} on the current line?\n        nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error(\"Unclosed tag at \" + scanner.pos);\n      }\n\n      tokens.push([type, value, start, scanner.pos]);\n\n      if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      }\n\n      // Set the tags for the next time around.\n      if (type === \"=\") {\n        tags = value.split(spaceRe);\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Template.js":"// Template.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Mustache = UI.Mustache,\n      Backbone = Monitor.Backbone,\n      _ = Monitor._,\n      FileProbe = Monitor.FileProbe,\n      FS = Monitor.commonJS ? require('fs') : null;\n\n  /**\n  * Template management\n  *\n  * This class provides template lifecycle and execution management.\n  *\n  * Templates are text strings in Mustache format.  A JavaScript object or\n  * Backbone.Model object may be applied to the template using the ```apply()```\n  * method.  This returns a text string with parameters replaced by the data\n  * model values.\n  *\n  *     var templateText = 'Hello {{what}}';\n  *     var myTemplate = new UI.Template({text: templateText});\n  *     var myModel = {what: 'World'};\n  *     console.log(myTemplate.apply(myModel));\n  *\n  * Mustache man page: <a href=\"http://mustache.github.com/mustache.5.html\">http://mustache.github.com/mustache.5.html</a>\n  *\n  * If the template is constructed with raw text, or if the text element is set\n  * after construction, the template function will reflect the text element.\n  *\n  * If the template is constructed on the server using a filename, that file\n  * is watched for changes and automatically reloaded if the file changes.\n  *\n  * To provide consistent calling behavior, the first file load is synchronous\n  * and subsequent file loads (due to changes) are asynchronous.  This assures\n  * consistent calling semantics regardless of the template source.\n  *\n  * Since synchronous file loading is only appropriate during process startup,\n  * if instances are needed after process start, the asyncLoad parameter can\n  * be passed to the constructor, and the 'change:text' event can be monitored\n  * as notification that the template is ready.\n  *\n  * @class Template\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model\n  *   @param [model.id] {String} A unique identifier for this template\n  *   @param [model.text] {String} The raw template text\n  *   @param [model.path] {String} The full path to a template file (server side only)\n  *   @param [model.asyncLoad=false] {Boolean} Should the initial file load be asynchronous?\n  *   @param [model.watchFile=true] {Boolean} Should the file specified by path be watched for changes?\n  *   @param [model.compiled] {Function} The compiled template function\n  */\n  var Template = UI.Template = Backbone.Model.extend({\n\n    defaults:  {\n      id: null, path:null, asyncLoad:false, text:null, watchFile: true, compiled:null\n    },\n\n    // Initialize the template\n    initialize: function(params, options) {\n      var t = this;\n\n      // If raw text was sent to the template, compile and return\n      if (t.get('text')) {\n        t.compile();\n        return;\n      }\n\n      // Watch for changes in the text element\n      t.on('change:text', t.compile, t);\n\n      // Process a file template\n      var path = t.get('path');\n      if (path) {\n        // Load the file\n        if (t.asyncLoad) {\n          FS.readFile(path, function(err, text) {\n            if (err) {\n              return console.error('Error reading file: ' + path, err);\n            }\n            t.set({text: text.toString()});\n          });\n        } else {\n          t.set({text: FS.readFileSync(path).toString()});\n        }\n\n        // Watch the file for changes\n        if (t.get('watchFile')) {\n          t._watchFile();\n        }\n      }\n    },\n\n    /**\n    * Watch the file for changes\n    *\n    * This sets up a watcher for the file specified in the ```path``` element.\n    * It is called by the constructor if the ```watchFile``` data element is true.\n    *\n    * @private\n    * @method _watchFile\n    */\n    _watchFile: function() {\n      var t = this, path = t.get('path');\n      t.watcher = FileProbe.watchLoad(path, {persistent: true}, function(error, content) {\n        if (!error) {\n          t.set('text', content);\n        }\n      });\n    },\n\n    /**\n    * Stop watching for file changes\n    *\n    * @method unWatchFile\n    */\n    unWatchFile: function() {\n      var t = this;\n      if (t.watcher) {\n        t.watcher.close();\n        t.watcher = null;\n      }\n    },\n\n    /**\n    * Apply the parameters to the template\n    *\n    * This accepts an object and returns the template with the parameters\n    * applied.\n    *\n    * @method apply\n    * @param params {Object or Backbone.Model} Parameters to apply to the template\n    * @return {String} The template text with parameters applied\n    */\n    apply: function(params) {\n      var t = this, text = t.get('text'), compiled = t.get('compiled');\n\n      // Convert parameters to JS object if they're a backbone model\n      if (params instanceof Backbone.Model) {\n        params = params.toJSON();\n      }\n\n      // Compile the template if necessary\n      if (!compiled) {\n        compiled = t.compile();\n      }\n\n      // Apply the template\n      return compiled(params);\n    },\n\n    /**\n    * Compile the text element into the compiled element\n    *\n    * @protected\n    * @method compile\n    * @return {Function} Compiled function ready to call\n    */\n    compile: function() {\n      var t = this, text = t.get('text');\n      var compiled = Mustache.compile(text);\n      t.set({compiled: compiled});\n      return compiled;\n    }\n\n  });\n\n  /**\n  * Build a new Template object from the contents of DOM\n  *\n  * This builds a new Template object, and sets the text element\n  * to the contents of the specified DOM HTML.\n  *\n  * It can only be run on the client.\n  *\n  * @static\n  * @method fromDOM\n  * @param selector {String} DOM selector\n  * @return {Template} The new template object\n  */\n  Template.fromDOM = function(selector) {\n    return new Template({text: $(selector).html()});\n  };\n\n  /**\n  * Indent (or un-indent) text by a specified number of characters\n  *\n  * If the numChars parameter is negative, un-indent.\n  *\n  * @static\n  * @method indent\n  * @param text {String} Text string\n  * @param numChars {Integer} Number of characters to indent or un-indent\n  * @return {String} The indented text\n  */\n  Template.indent = function(text, numChars) {\n    for (var i = 0, indent = ''; i < Math.abs(numChars); i++) {indent += ' ';}\n    if (numChars <= 0) {\n      // Un-indent\n      var re = new RegExp('^' + indent, 'mg');\n      return text.replace(re, '');\n    } else {\n      // Indent\n      var blankLastLine = new RegExp('\\n' + indent + '$');\n      return text.replace(/^/mg, indent).replace(blankLastLine, '\\n');\n    }\n  };\n\n  /**\n  * Constructor for a list of Template objects\n  *\n  *     var myList = new Template.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Template data model objects.\n  * @return {Backbone.Collection} Collection of Template data model objects\n  */\n  Template.List = Backbone.Collection.extend({model: Template});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Site.js":"// Site.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Backbone = Monitor.Backbone, _ = Monitor._;\n\n  /**\n  * This represents the Node.js Monitor web site\n  *\n  * @class Site\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param [model.name] {String} The site name\n  *     @param [model.logo] {String} URL to the site logo\n  *     @param [model.favicon] {String} URL to the favicon\n  *     @param [model.css] {String} CSS overrides to apply to all pages\n  *     @param [model.tours] {Tour.List} All tours registered on the site (less the pages)\n  */\n  var Site = UI.Site = Backbone.Model.extend({\n\n    defaults: {\n      id: 'default',\n      name:'Node Monitor',\n      logo:'/static/css/default/images/monitor.jpg',\n      favicon: '/static/css/default/images/favicon.ico',\n      css: '',\n      tours: []\n    },\n    sync: new Monitor.Sync('Site')\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Component.js":"/*global window document $ localStorage alert*/\n\n// Component.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Backbone = Monitor.Backbone,\n      _ = Monitor._;\n\n  /**\n  * An element on the page canvas\n  *\n  * Components represent the visual elements on a page.  They contain the data\n  * necessary to instantiate a Java view, and a single monitor to provide data\n  * to the view.\n  *\n  * A component contains and persists information required to instantiate, position,\n  * and connect a Backbone View with a Monitor (as the data model for the view).\n  *\n  * @class Component\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.id {String} - Name of the component within the form\n  *     @param model.viewClass {String} - Class name of the view (must be exposed on the Monitor.UI class)\n  *     @param model.viewOptions {Backbone.Model} - Options passed on to the view constructor\n  *         @param model.viewOptions.title {String} - Component title to display\n  *         @param model.viewOptions.background {boolean} - Display the component background?\n  *     @param model.monitor {Monitor} - The monitor attached to the component (always there)\n  *     @param model.css {Object} - Map of CSS selector to CSS styles to apply to the component\n  *     @param model.notes {String} - Notes associated with the view\n  *     @param model.onInit {String} - JavaScript to run when the view and monitor model have been initialized and rendered.\n  *       The JS has access to the local variables:\n  *         view - The rendered view object\n  *         monitor - The Monitor object\n  *         pageView - The PageView object representing the web page\n  *       ```this``` is the ComponentView object.\n  */\n  var Component = UI.Component = Backbone.Model.extend({\n\n    defaults: {\n      id:'',\n      viewClass:'',\n      viewOptions:{},\n      monitor: {},\n      css:{},\n      notes:'',\n      onInit: ''\n    },\n\n    initialize: function(params, options) {\n      var t = this;\n\n      // Attach sub-model containment\n      UI.containedModel(t, 'viewOptions', Backbone.Model);\n      UI.containedModel(t, 'monitor', Monitor);\n    },\n\n    /**\n    * Set the default component size\n    *\n    * This will add CSS to set the component size if it hasn't already been set.\n    *\n    * @method setDefaultSize\n    * @param size {Object}\n    *     @param size.height {Integer} Default height\n    *     @param size.width {Integer} Default width\n    */\n    setDefaultSize: function(size) {\n      var t = this,\n          css = _.clone(t.get('css')),\n          parsedCss = $.parseStyleString(css['.nm-cv-viewport'] || '');\n      if (!parsedCss.height && !parsedCss.width) {\n        parsedCss.height = size.height + 'px';\n        parsedCss.width = size.width + 'px';\n        css['.nm-cv-viewport'] = $.makeStyleString(parsedCss);\n        t.set({css: css});\n      }\n    },\n\n    // Overridden to produce only the persistent portion of the page\n    toJSON: function(options) {\n      var t = this,\n          opts = _.extend({trim:true, deep:true, monitorOnly:true}, options),\n          raw = Backbone.Model.prototype.toJSON.call(t, opts);\n\n      // Keep only the monitor portion (strip the probe portion)?\n      if (opts.monitorOnly) {\n        raw.monitor = t.get('monitor').toMonitorJSON(opts);\n      }\n      return raw;\n    }\n\n\n  });\n\n  /**\n  * Constructor for a list of Component objects\n  *\n  *     var myList = new Component.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Component data model objects.\n  * @return {Backbone.Collection} Collection of Component data model objects\n  */\n  Component.List = Backbone.Collection.extend({model: Component});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Page.js":"// Page.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Component = UI.Component,\n      Backbone = Monitor.Backbone, _ = Monitor._;\n\n  /**\n  * A page on the node_monitor site\n  *\n  * All pages on the node_monitor site are dynamically defined, and represented\n  * by an instance of this class.\n  *\n  * @class Page\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.id {String} The page url within the site\n  *     @param [model.title] {String} The page title\n  *     @param [model.description] {String} Description of the page\n  *     @param [model.notes] {String} Page notes\n  *     @param model.onInit {String} - JavaScript to run when the Page model and PageView have been initialized and rendered.\n  *       The JS has access to two local variables: pageModel and pageView.\n  *     @param [model.css] {Object} - Key/value map of CSS selector to CSS overrides to apply to the entire page\n  *     @param [model.components] {Component.List} - List of components on the page\n  */\n  var Page = UI.Page = Backbone.Model.extend({\n\n    defaults: {\n      id:'',\n      title:'',\n      description:'',\n      notes:'',\n      onInit:'',\n      css:{},\n      components:[]\n    },\n    sync: new Monitor.Sync('Page'),\n\n    initialize: function(params, options) {\n      var t = this;\n      UI.containedModel(t, 'components', Component.List);\n    },\n\n    /**\n    * Add a new component to the Page model by component class\n    *\n    * This uses the default component attributes\n    *\n    * @method addComponent\n    * @param viewClass - Class name for the main view in the component\n    * @return component - The newly instantiated component\n    */\n    addComponent: function(viewClass) {\n      var t = this,\n          newIdNum = 1,\n          components = t.get('components'),\n          classParts = viewClass.split('.'),\n          appName = classParts[0],\n          appView = classParts[1];\n\n      // Instantiate and add the component\n      var component = new Component({\n        id: Monitor.generateUniqueCollectionId(components, 'c'),\n        viewClass: viewClass,\n        viewOptions: UI.app[appName][appView].prototype.defaultOptions,\n        css: {\n          '.nm-cv': 'top:10px;'\n        }\n      });\n      components.add(component);\n      return component;\n    },\n\n    // Overridden to override some options\n    toJSON: function(options) {\n      var t = this,\n          opts = _.extend({trim:true, deep:true}, options),\n          raw = Backbone.Model.prototype.toJSON.call(t, opts);\n      return raw;\n    }\n\n  });\n\n  /**\n  * Constructor for a list of Page objects\n  *\n  *     var myList = new Page.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Page data model objects.\n  * @return {Backbone.Collection} Collection of Page data model objects\n  */\n  Page.List = Backbone.Collection.extend({model: Page});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Tree.js":"// Tree.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Backbone = Monitor.Backbone,\n      _ = Monitor._;\n\n  /**\n  * A data tree\n  *\n  * A tree is a hierarchical representation of objects.  Each node in the\n  * tree contains a list of objects representing leaves, and a list of other\n  * tree objects representing branches.\n  *\n  * This model is designed for interactive use in a view.  It contains elements\n  * representing visual state such as open/closed.\n  *\n  * @class Tree\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.id {String} - The identifier for this node (relative to parent).  Required.\n  *     @param [model.label=''] {String} - The display label (if different from the ID)\n  *     @param [model.description=''] {String} - The node extended description\n  *     @param model.branches {Tree.List} - Ordered list of branches.\n  *     @param model.leaves {Backbone.Collection} - Ordered list of objects at this level.\n  *     @param [model.isOpen=false] {boolean} - Is this currently visually opened?\n  */\n  var Tree = UI.Tree = Backbone.Model.extend({\n\n    defaults: {\n      id:'',\n      label: '',\n      description: ''\n      // Don't default these because sub-tree branches aren't set in monitors\n      // and defaulting them would clear out existing values.\n      // branches: [],\n      // leaves: [],\n      // isOpen: false\n    },\n\n    initialize: function(params, options) {\n      var t = this;\n\n      // Connect sub-models if present\n      if (t.has('leaves')) {\n        UI.containedModel(t, 'leaves', Backbone.Collection);\n      }\n      if (t.has('branches')) {\n        UI.containedModel(t, 'branches', Tree.List);\n      }\n    },\n\n    /*\n    * Get a tree node by path\n    *\n    * @method getByPath\n    * @param path {String | Array} Path to the node (Path parts, or a string with '/' separators)\n    * @return {Backbone.Model} The node at the specified path (or null if it doesn't exist)\n    */\n    getByPath: function(path) {\n      var t = this;\n\n      // Get the parts\n      var parts = Array.isArray(path) ? path : path.split('/').filter(function(item){return item;});\n\n      // Return the item at this level\n      if (parts.length === 1) {\n        return t.get('leaves').get(parts[0]);\n      }\n\n      // Return the item from the tree below\n      var sub = t.get('branches').get(parts[0]);\n      if (sub) {\n        return sub.getByPath(parts.slice(1));\n      }\n\n      // Branch not found\n      return null;\n    },\n\n    /*\n    * Attach a TreeNode monitor to this node in the tree\n    *\n    * This watches for changes in the monitor, calling the\n    * onMonitorChange method when it detects a change in the monitor.\n    *\n    * @method attachMonitor\n    * @param monitor {Monitor} A Monitor to watch for changes on.\n    */\n    attachMonitor: function(monitor) {\n      var t = this;\n\n      // Detach any prior monitor\n      if (t.monitor) {\n        t.detachMonitor();\n      }\n\n      // Watch for changes\n      t.monitor = monitor;\n      t.monitor.on('change', t.onMonitorChange, t);\n    },\n\n    /*\n    * Is there a monitor attached to this node?\n    *\n    * @method hasMonitor\n    * @return monitored {boolean} True if there is a monitor on this node\n    */\n    hasMonitor: function() {\n      var t = this;\n      return t.monitor ? true : false;\n    },\n\n    /*\n    * Merge monitor changes into this node.\n    *\n    * This can be called to synchronize the monitor contents with\n    * this tree node.\n    *\n    * @method onMonitorChange\n    */\n    onMonitorChange: function() {\n      var t = this,\n          monitor = t.monitor;\n\n      // Default leaves & branches when the monitor comes back\n      if (!t.has('leaves')) {\n        t.set('leaves',[]);\n        UI.containedModel(t, 'leaves', Backbone.Collection);\n      }\n      if (!t.has('branches')) {\n        t.set('branches',[]);\n        UI.containedModel(t, 'branches', Tree.List);\n      }\n\n      // Update leaves and branches using the Backbone\n      // collection update command.  This performs add/delete\n      // as necessary.\n      if (monitor.has('leaves')) {\n        t.get('leaves').update(monitor.get('leaves'));\n      }\n      if (monitor.has('branches')) {\n        // Use the UI.Collection.set() vs. Collection.update() to keep\n        // deep event listeners in place.\n        t.get('branches').set(monitor.get('branches'));\n      }\n\n    },\n\n    /*\n    * Detach the TreeNode monitor from this node in the tree\n    *\n    * This detaches the currently attached monitor from this tree node.\n    *\n    * @method detachMonitor\n    */\n    detachMonitor: function() {\n      var t = this;\n\n      // Detach any prior monitor\n      if (t.monitor) {\n        t.monitor.off('change', t.onMonitorChange, t);\n        delete t.monitor;\n      }\n    }\n\n  });\n\n  /**\n  * Constructor for a list of Tree objects\n  *\n  *     var myList = new Tree.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Tree data model objects.\n  * @return {Backbone.Collection} Collection of Tree data model objects\n  */\n  Tree.List = Backbone.Collection.extend({model: Tree});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Tour.js":"// Tour.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('monitor'),\n      UI = Monitor.UI,\n      Component = UI.Component,\n      Backbone = Monitor.Backbone, _ = Monitor._;\n\n  /**\n  * A site tour on the node_monitor site\n  *\n  * Tours are an ordered sequence of pages on the site.  They can be used\n  * to explore features, or for hands-off paging through dashboards.\n  *\n  * @class Tour\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.id {String} The unique tour key\n  *     @param [model.title] {String} The display name for the tour\n  *     @param [model.description] {String} Description of the tour\n  *     @param model.pages [Array] - Array of pages in the tour\n  *         @param model.pages.title - Page title\n  *         @param model.pages.url - Page URL\n  *     @param [model.autoNextSec=0] {Number} - Number of seconds to stay on a page\n  *         before navigating to the next page.  0=no autoNext.\n  */\n  var Tour = UI.Tour = Backbone.Model.extend({\n\n    defaults: {\n      id:'',\n      title:'',\n      description:'',\n      autoNextSec: 10,\n      pages:[]\n    },\n    sync: new Monitor.Sync('Tour'),\n\n    initialize: function(params, options) {\n      var t = this;\n    }\n\n  });\n\n  /**\n  * Constructor for a list of Tour objects\n  *\n  *     var myList = new Tour.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Tour data model objects.\n  * @return {Backbone.Collection} Collection of Tour data model objects\n  */\n  Tour.List = Backbone.Collection.extend({model: Tour});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/NetworkMap.js":"// NetworkMap.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('monitor'),\n      _ = Monitor._,\n      log = Monitor.getLogger('NetworkMap'),\n      Probe = Monitor.Probe;\n\n  /**\n  * Probe for exposing and managing the map of servers known to this network.\n  * This is designed to support client-side discovery for connecting a probe.\n  *\n  * The map looks like this:\n  *\n  *     hostName1: {\n  *       appName1: {\n  *         instances: [array, of, instance, ids],\n  *         probeClasses: ['array','of','available','probe','classes']\n  *       },\n  *       appName2: {...}\n  *     },\n  *     hostName2: {...}\n  *\n  * The 'localhost' server in the map represents this server process.\n  *\n  * @class NetworkMap\n  * @extends Probe\n  * @constructor\n  * @param [model] - Probe data model.\n  *     @param model.map {Object} Site map (see above for definition)\n  *\n  */\n  var NetworkMap = Monitor.NetworkMap = Probe.extend({\n\n    probeClass: 'NetworkMap',\n    defaults: {\n      map: {}\n    },\n\n    initialize: function(attributes, options){\n      var t = this,\n          router = Monitor.getRouter();\n\n      // Build the initial site map, updating as connections come and go\n      t.updateSequence = 0,\n      t.buildNetworkMap();\n      router.on('connection:add connection:remove', t.buildNetworkMap, t);\n    },\n\n    /**\n    * Attempt to add a server to the site map.\n    *\n    * This probe control is called to ping a montor server with the specified\n    * host name.  If a monitor server is available on the specified host, it\n    * will be added to the site map, causing the probe to be updated with the\n    * server information.\n    *\n    * @method pingServer_control\n    * @param hostName {String} Server host name\n    * @param callback {Function(error)}\n    *     @param callback.error {Mixed} Set if this couldn't connect with any\n    *            monitor processes on the specified server.\n    */\n    pingServer_control: function(hostName, callback) {\n\n      //\n      // Monitor.getRouter().addHostConnections(hostName, function(error) {\n      //   if (error) {callback(error);}\n    },\n\n    // This builds a new site map, and sets it into the map property\n    // if it is different from the current map.\n    buildNetworkMap: function() {\n      var t = this,\n          map = {},\n          router = Monitor.getRouter(),\n          hostName = Monitor.getRouter().getHostName(),\n          appName = Monitor.Config.Monitor.appName,\n          appInstance = process.env.NODE_APP_INSTANCE;\n\n      // Add this process to the map\n      map[hostName] = {};\n      map[hostName][appName] = {\n        instances: [appInstance],\n        probeClasses: _.keys(Probe.classes)\n      };\n\n      // Process all known connections\n      var connections = router.findConnections();\n      connections.forEach(function(connection) {\n        hostName = connection.get('hostName') || connection.get('remoteHostName');\n        appName = connection.get('remoteAppName') || '';\n        appInstance = connection.get('remoteAppInstance') || '';\n\n        // Don't add to the map not yet connected\n        if (connection.connecting || !connection.connected) {\n          return;\n        }\n\n        // Add the hostname to the map\n        var host = map[hostName];\n        if (!host) {\n          host = map[hostName] = {};\n        }\n\n        // Add the app to the map\n        var app = host[appName];\n        if (!app) {\n          app = host[appName] = {\n            instances: [appInstance],\n            probeClasses: connection.get('remoteProbeClasses')\n          };\n        } else {\n          app.instances.push(appInstance);\n        }\n      });\n      log.info('buildMap', map);\n\n      // Set the map if it's changed.  This method is called whenever\n      // connections come and go - including firewalled connections which\n      // aren't visible in the map.  Only update if the map has changed.\n      if (!_.isEqual(map, t.get('map'))) {\n        log.info('mapChanged');\n        t.set({\n          map: map,\n          updateSequence: t.updateSequence++\n        });\n      } else {\n        log.info('mapNotChanged');\n      }\n    },\n\n    // Remove event handlers on probe release\n    release: function() {\n      var t = this,\n          router = Monitor.getRouter();\n      router.off('connection:add connection:remove', t.buildNetworkMap, t);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/Server.js":"/*global window document $ localStorage alert*/\n\n// Server.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading\n  var Monitor = require('monitor'),\n      UI = Monitor.UI,\n      $ = UI.$,\n      Backbone = Monitor.Backbone,\n      _ = Monitor._,\n      SyncProbe = Monitor.SyncProbe,\n      Mustache = Monitor.commonJS ? require('../ext/mustache-0.7.0-dev.js') : root.Mustache;\n      Page = UI.Page,\n      pageCache = new Page.List(),\n      Site = UI.Site,\n      Connect = require('connect'),\n      Config = require('config'),\n      GruntConfig = require('../../grunt'),\n      FS = require('fs'),\n      OS = require('os'),\n      Path = require('path'),\n      URL = require('url'),\n      log = Monitor.getLogger('Server'),\n      Template = UI.Template;\n\n  // Constants\n  var PAGE_PARAMS = {},\n      CSS_TEMPLATE   = Mustache.compile('\\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{{cssFile}}}\">'),\n      JS_TEMPLATE    = Mustache.compile('\\n    <script type=\"text/javascript\" src=\"{{{scriptFile}}}\"></script>'),\n      TMPL_TEMPLATE  = Mustache.compile('\\n      <div id=\"nm-template-{{id}}\">\\n{{{text}}}      </div>'),\n      PACKAGE_JSON   = JSON.parse(FS.readFileSync(__dirname + '/../../package.json'));\n\n  /**\n  * Server side support for the monitor UI.\n  *\n  * @module Server\n  */\n\n  /**\n  * Monitor user interface Server\n  *\n  * Instances of this class build a UI server listening on a port.  The server\n  * is created and set up during object initialization.\n  *\n  * @class Server\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model\n  *   @param [model.port=4200] {Number} The server listens on this port\n  *   @param [model.allowExtrnalConnections=false] {boolean} Allow connections\n  *     from host processes outside this machine?\n  *   @param [model.server] {ConnectServer} A custom connect or express server\n  *   @param [model.templates] {Template.List} List of templates available to the server\n  */\n  var Server = UI.Server = Backbone.Model.extend({\n\n    defaults: _.extend({\n      port:4200,\n      allowExternalConnections: false,\n      siteDbPath: './site_db',\n      server:null,\n      templates:new Template.List()\n    }, Config.Monitor),\n\n    // Initialize the server\n    initialize: function(params, options) {\n      var t = this,\n          port = t.get('port'),\n          server = t.get('server'),\n          templates = t.get('templates'),\n          siteDbPath = t.get('siteDbPath'),\n          parentPath = siteDbPath.indexOf('.') === 0 ? process.cwd() : '';\n\n      // Distribute the site path to probes that need it\n      t.set('siteDbPath', Path.join(parentPath, siteDbPath));\n\n      // Initialize probes\n      SyncProbe.Config.defaultProbe = 'FileSyncProbe';\n      SyncProbe.FileSyncProbe.setRootPath(siteDbPath);\n\n      // Expose the current instance so probes running\n      // in this process can communicate with the server\n      UI.Server.currentServer = t;\n\n      // Internal (non-model) attributes\n      t.apps = {};  // Hash appName -> app data\n      t.site = null;   // Site model associated with the server\n\n      // Create a connect server if no custom server was specified\n      if (!server) {\n        server = new Connect();\n        t.set({server: server});\n      }\n\n      // Attach server components\n      server.use(t.siteRoute.bind(t));\n      server.use(Connect['static'](Path.join(__dirname, '/../..')));\n\n      // Create a static server to the monitor distribution\n      var monitorDistDir = require.resolve('monitor').replace(/lib[\\\\\\/]index.js/, 'dist');\n      t.monitorDist = Connect['static'](monitorDistDir);\n\n      // Initialize the template library\n      var gruntModules = GruntConfig.MODULE_DEF;\n      gruntModules.templates.sort().forEach(function(template){\n        var path = Path.normalize(__dirname + '/../../' + template);\n        var id = Path.basename(path, '.html');\n        templates.add({id:id, path:path});\n      });\n\n      // Build the page parameters from the config file\n      var styles = \"\", scripts=\"\";\n      gruntModules.client_css.forEach(function(cssFile) {\n        styles += CSS_TEMPLATE({cssFile: cssFile.replace('lib/','/static/')});\n      });\n      var clientScripts = gruntModules.client_ext.concat(gruntModules.shared_js.concat(gruntModules.client_js));\n      clientScripts.forEach(function(file) {\n        scripts += JS_TEMPLATE({scriptFile: file.replace('lib/','/static/')});\n      });\n      _.extend(PAGE_PARAMS, {\n        styles: styles, scripts: scripts, version: PACKAGE_JSON.version\n      });\n    },\n\n    /**\n    * Internal route for all non-static site endpoints\n    *\n    * @method siteRoute\n    * @param request {Connect.Request} The http request object\n    * @param response {Connect.Response} The http response object\n    * @param next {Function()} Function to pass control if this doesn't handle the url.\n    */\n    siteRoute: function(request, response, next) {\n      var t = this;\n\n      // URL rewrites\n      var url = URL.resolve('', request.url);\n      if (url === '/favicon.ico') {\n        var faviconUrl = t.site.get('favicon');\n        url = request.url = faviconUrl || request.url;\n      }\n\n      // Remove the leading slash for page manipulation\n      url = url.substr(1);\n\n      // Rewrite the url and forward if it points to static content\n      var urlParts = url.split('/');\n      if (urlParts[0] === 'static') {\n\n        // Replace static with lib, and put the leading slash back in\n        request.url = url.replace('static/', '/lib/');\n\n        // Forward to the monitor distribution\n        if (request.url.indexOf('monitor-all.js') > 0) {\n          request.url = '/monitor-all.js';\n          return t.monitorDist(request, response, next);\n        }\n\n        // Next is the static server\n        return next();\n      }\n\n      // If it's an URL to an app, route to the app\n      if (urlParts[0] === 'app') {\n        var appName = urlParts[1],\n            app = t.apps[appName];\n\n        // Route to a monitor page if the app doesn't handle the request\n        var appNext = function() {\n          t._monitorPageRoute(request, response, next);\n        };\n\n        // Continue if the app isn't defined\n        if (!app) {\n          return appNext();\n        }\n\n        // Make the app request relative to the app\n        var appUrl = '/' + url.split('/').slice(2).join('/'),\n            appRequest = _.extend({}, request, {url: appUrl});\n\n        // Forward the request to the app server\n        var server = typeof app.server === 'function' ? app.server : app.staticServer;\n        return server(appRequest, response, appNext);\n      }\n\n      // Forward to a monitor page\n      t._monitorPageRoute(request, response, next);\n    },\n\n    /**\n    * Route to a monitor page.\n    *\n    * @protected\n    * @method _monitorPageRoute\n    * @param request {Connect.Request} The http request object\n    * @param response {Connect.Response} The http response object\n    * @param next {Function()} Function to pass control if this doesn't handle the url.\n    */\n    _monitorPageRoute: function(request, response, next) {\n      var t = this,\n          url = request.url,\n          searchStart = url.indexOf('?'),\n          templates = t.get('templates');\n\n      // Remove any URL params\n      if (searchStart > 0) {\n        url = url.substr(0, searchStart);\n      }\n\n      // Get the page model\n      t._getPage(url, function(error, pageModel) {\n\n        if (error) {\n          return response.end('page error: ' + JSON.stringify(error));\n        }\n\n        // Build the object to put into the page template\n        var page = _.extend({templates:''}, PAGE_PARAMS, t.site.toJSON(), pageModel.toJSON());\n        page.pageParams = Template.indent(JSON.stringify(pageModel.toJSON({deep:true,trim:true}), null, 2), 8);\n\n        // Add all watched templates except the main page\n        templates.each(function(template) {\n          if (template.id !== 'UI') {\n            page.templates += TMPL_TEMPLATE({\n              id:template.id,\n              text:Template.indent(template.get('text'),8)\n            });\n          }\n        });\n\n        // Output the page\n        response.writeHead(200, {'Content-Type': 'text/html'});\n        var pageTemplate = templates.get('UI');\n        return response.end(pageTemplate.apply(page));\n      });\n    },\n\n    /**\n    * Get the specified page from cache\n    *\n    * This retrieves the page from cache, or puts it there.\n    *\n    * @method _getPage\n    * @param url {url} URL to the page\n    * @param callback {function(error, pageModel)} Called when complete\n    */\n    _getPage: function(url, callback) {\n      var t = this,\n          originalUrl = url,\n          page = null;\n\n      // Change urls that end in / to /index\n      if (url.substr(-1) === '/') {\n        url = url + 'index';\n      }\n\n      // Return if it's in cache\n      page = pageCache.get(url);\n      if (page) {\n        return callback(null, page);\n      }\n\n      // Read from storage\n      page = new Page({id: url});\n      page.fetch({liveSync: true, silenceErrors: true}, function(error) {\n\n        // Process a 404.  This returns a transient page copied from\n        // the default 404 page, with the id replaced by the specified url.\n        if (error && error.code === 'NOTFOUND' && url !== '/app/core/404') {\n\n          // Default the home page if notfound\n          if (originalUrl === '/') {\n            return t._getPage('/app/core/index', callback);\n          }\n\n          // Default the 404 page if notfound\n          if (originalUrl === '/404') {\n            return t._getPage('/app/core/404', callback);\n          }\n\n          // Otherwise it's a new page.  Create it.\n          t._getPage('/404', function(error, page404) {\n            if (error) {\n              console.error(\"Error loading the 404 page\", error);\n              return callback('404 page load error');\n            }\n\n            // Copy the 404 page into a new page\n            var newPage = new Page(JSON.parse(JSON.stringify(page404)));\n\n            // Build a sane starting title.  TitleCase the last url element, separate words, replace underscores\n            var title = $.titleCase(url.split('/').pop(), true).replace(/([A-Z])/g,\" $1\").replace(/^ /,'').replace(/_/g,' ');\n            var title = url.split('/').pop().replace(/([A-Z])/g,\" $1\").replace(/^ /,'').replace(/_/g,' ');\n            newPage.set({id:url, title:title, is404page:true});\n            callback(null, newPage);\n          });\n          return;\n        }\n\n        // Process other errors\n        if (error) {\n          return callback(error);\n        }\n\n        // Assure the page model ID is correct on disk\n        if (url !== page.get('id')) {\n          page.set('id', url);\n        }\n\n        // Put the page into cache and return it\n        pageCache.add(page);\n        return callback(null, page);\n      });\n    },\n\n    /**\n    * Start the UI server\n    *\n    * This method starts listening for incoming UI requests.\n    *\n    * @method start\n    * @param [callback] {Function(error)} - Called when the server has started\n    */\n    /**\n    * The server has started\n    *\n    * This event is fired when the server has begun listening for incoming\n    * web requests.\n    *\n    * @event start\n    */\n    /**\n    * A client error has been detected\n    *\n    * This event is fired if an error has been detected in the underlying\n    * transport.  It may indicate message loss.\n    *\n    * @event error\n    */\n    start: function(callback) {\n      callback = callback || function(){};\n      var t = this,\n          server = t.get('server'),\n          port = t.get('port'),\n          allowExternalConnections = t.get('allowExternalConnections');\n\n      // Allow connections from INADDR_ANY or LOCALHOST only\n      var host = allowExternalConnections ? '0.0.0.0' : '127.0.0.1';\n\n      // Start listening\n      server.listen(port, host, function(){\n\n        // Allow the UI server to be a Monitor gateway server\n        t.monitorServer = new Monitor.Server({server:server, gateway: true});\n        t.monitorServer.start(function(){\n\n          // Called after the site object is loaded\n          var onSiteLoad = function(error) {\n            if (error) {\n              return callback(error);\n            }\n\n            // Discover and initialize application modules\n            t.loadApps();\n\n            // Bind server events\n            t._bindEvents(callback);\n          };\n\n          // Load and keep the web site object updated\n          t.site = new Site();\n          t.site.fetch({liveSync: true, silenceErrors:true}, function(error) {\n\n            // Initialize the site if it's not found\n            if (error && error.code === 'NOTFOUND') {\n              t.site = new Site();\n              t.site.id = null;  // This causes a create vs. update on save\n              return t.site.save({}, {liveSync: true}, onSiteLoad);\n            } else if (error) {\n              return onSiteLoad(error);\n            }\n\n            // Bind server events once connected\n            onSiteLoad();\n          });\n        });\n      });\n    },\n\n    /**\n    * Bind incoming socket events to the server\n    *\n    * @protected\n    * @method _bindEvents\n    * @param callback {Function(error)} - Called when all events are bound\n    */\n    _bindEvents: function(callback) {\n\n      // Detect server errors\n      var t = this, server = t.get('server');\n      server.on('clientError', function(err){\n        console.error('Client error detected on server', err);\n        t.trigger('error', err);\n      });\n      server.on('close', function(err){\n        server.hasEmittedClose = true;\n        t.stop();\n      });\n\n      // Notify that we've started\n      t.isListening = true;\n      if (callback) {\n        callback(null);\n      }\n      t.trigger('start');\n    },\n\n    /**\n    * Discover and load all node_monitor application modules\n    *\n    * This is designed to run during server initialization, and is synchronous.\n    *\n    * @method loadApps\n    */\n    loadApps: function() {\n      var t = this;\n\n      // Test an app directory to see if it's a monitor app\n      var testAppDir = function(dir) {\n\n        // Load the package.json if it exists (and remove relative refs)\n        var pkg;\n        dir = Path.resolve(dir);\n        try {\n          pkg = JSON.parse(FS.readFileSync(dir + '/package.json', 'utf-8'));\n        } catch (e) {\n          // Report an error if the package.json has a parse problem.  This is\n          // good during app development to show why we didn't discover the app.\n          if (e.code !== \"ENOENT\") {\n             console.error(\"Problem parsing \" + dir + \"/package.json\");\n          }\n          return false;\n        }\n\n        // Is this a monitor-dashboard app?\n        var isMonitorApp = pkg.dependencies && _.find(_.keys(pkg.dependencies), function(keyword){ return keyword === 'monitor-dashboard'; });\n        if (!isMonitorApp) {\n          return false;\n        }\n\n        // This is a monitor-dashboard app.\n        return t.loadApp(dir, pkg);\n      };\n\n      // Process all apps under a node_modules directory\n      var loadNodeModulesDir = function(dir) {\n\n        // Return if the node_modules directory doesn't exist.\n        try {\n          FS.statSync(dir);\n        } catch (e) {return;}\n\n        // Check each direcory for a monitor-dashboard app\n        FS.readdirSync(dir).forEach(function(moduleName) {\n\n          // See if this is a monitor app, and load if it is\n          // then load sub-modules\n          var moduleDir = dir + '/' + moduleName;\n          if (testAppDir(moduleDir) || moduleName === 'monitor') {\n\n            // If it is a monitor-app, process any sub node_modules\n            loadNodeModulesDir(moduleDir + '/node_modules');\n          }\n        });\n      };\n\n      // Test this app as a monitor app\n      t.thisAppName = testAppDir('.');\n\n      // Process all possible node_module directories in the require path.\n      process.mainModule.paths.forEach(loadNodeModulesDir);\n\n    },\n\n    /**\n    * Load the specified app\n    *\n    * This is designed to run during server initialization, and is synchronous.\n    *\n    * @method loadApp\n    * @param moduleDir {String} The module directory that contains package.json\n    * @param packageJson {Object} The contents of the package.json file\n    */\n    loadApp: function(moduleDir, packageJson) {\n      var t = this,\n          resolved = null,\n          templates = t.get('templates');\n\n      // Remove the -monitor portion of the app\n      var appName = packageJson.name.replace(/-monitor$/,'');\n\n      // Don't overwrite a more \"locally\" defined app\n      if (t.apps[appName]) {\n        return false;\n      }\n\n      // The app module must be found\n      try {\n        resolved = require.resolve(moduleDir);\n      } catch (e) {\n        console.error(\"Problem loading plug-in: \" + moduleDir, e);\n        return false;\n      }\n\n      // Clear module cache for reloads\n      log.info('Loading app ' + appName + ' from ' + moduleDir);\n      delete require.cache[resolved];\n\n      // Load the module\n      var server;\n      try {\n        server = require(resolved);\n      } catch (e) {\n        console.error('Problem loading the \"' + appName + '\" module: ', e.stack);\n        return false;\n      }\n\n      var views = {}, // key: view name, value: {icon:'iconfile'}\n          css = [],\n          images = {}, // key: basename, value: filename\n          appPath = '/app/' + appName + '/';\n\n      // Add extensions\n      try {\n        FS.readdirSync(moduleDir + '/lib/ext').sort().forEach(function(filename) {\n          var ext = Path.extname(filename).toLowerCase();\n          var base = Path.basename(filename, ext);\n          if (ext === '.js') {\n            PAGE_PARAMS.scripts += JS_TEMPLATE({scriptFile: appPath + 'ext/' + filename});\n          }\n        });\n      } catch (e) {\n        if (e.code !== 'ENOENT') {\n          console.error('Error reading ' + moduleDir + '/lib/ext', e);\n        }\n      }\n\n      // Gather views to expose on the page\n      try {\n        FS.readdirSync(moduleDir + '/lib/view').sort().forEach(function(filename) {\n          var ext = Path.extname(filename).toLowerCase();\n          var base = Path.basename(filename, ext);\n          if (ext === '.js') {\n            views[base] = '';\n            PAGE_PARAMS.scripts += JS_TEMPLATE({scriptFile: appPath + 'view/' + filename});\n          }\n        });\n      } catch (e) {\n        if (e.code !== 'ENOENT') {\n          console.error('Error reading ' + moduleDir + '/lib/view', e);\n        }\n      }\n\n      // Gather CSS to expose on the page\n      try {\n        FS.readdirSync(moduleDir + '/lib/css').sort().forEach(function(filename) {\n          var ext = Path.extname(filename).toLowerCase();\n          var base = Path.basename(filename, ext);\n          if (ext === '.css') {\n            css.push(filename);\n            PAGE_PARAMS.styles += CSS_TEMPLATE({cssFile: appPath + 'css/' + filename});\n          }\n        });\n      } catch (e) {\n        if (e.code !== 'ENOENT') {\n          console.error('Error reading ' + moduleDir + '/lib/css', e);\n        }\n      }\n\n      // Gather templates to expose\n      try {\n        FS.readdirSync(moduleDir + '/lib/template').sort().forEach(function(filename) {\n          var ext = Path.extname(filename).toLowerCase();\n          var base = Path.basename(filename, ext);\n          if (ext === '.html') {\n            templates.add({id:appName + '-' + base, path:moduleDir + '/lib/template/' + filename});\n          }\n        });\n      } catch (e) {\n        if (e.code !== 'ENOENT') {\n          console.error('Error reading ' + moduleDir + '/lib/template', e);\n        }\n      }\n\n      // Gather images\n      try {\n        FS.readdirSync(moduleDir + '/lib/image').sort().forEach(function(filename) {\n          var ext = Path.extname(filename).toLowerCase();\n          var base = Path.basename(filename, ext);\n          if (ext.match('\\\\.jpg|\\\\.jpeg|\\\\.ico|\\\\.bmp|\\\\.tif|\\\\.tiff|\\\\.gif')) {\n            images[base] = appPath + 'image/' + filename;\n          }\n        });\n      } catch (e) {\n        if (e.code !== 'ENOENT') {\n          console.error('Error reading ' + moduleDir + '/lib/image', e);\n        }\n      }\n\n      // Match views to their icon image (if available)\n      for (var viewName in views) {\n        views[viewName] = {icon: images[viewName]};\n      }\n\n      // Record app information\n      t.apps[appName] = {\n        label: packageJson.label,\n        description: packageJson.description,\n        moduleDir: moduleDir,\n        server: server,\n        staticServer: Connect['static'](Path.join(moduleDir, '/view')),\n        views: views,\n        css: css\n      };\n\n      return appName;\n\n    },\n\n    /**\n    * Stop processing inbound web and monitor traffic\n    *\n    * This method stops accepting new inbound monitor connections, and closes\n    * all existing monitor connections associated with the server.\n    *\n    * @method stop\n    * @param callback {Function(error)} - Called when the server has stopped\n    */\n    /**\n    * The server has stopped\n    *\n    * This event is fired after the server has stopped accepting inbound\n    * connections, and has closed all existing connections and released\n    * associated resources.\n    *\n    * @event stop\n    */\n    stop: function(callback) {\n      var t = this, server = t.get('server');\n      callback = callback || function(){};\n\n      // Unwatch all template files\n      t.get('templates').forEach(function(template) {\n        template.unWatchFile();\n      });\n\n      // Don't stop more than once.\n      if (!t.isListening) {\n        return callback();\n      }\n\n      // Shut down the server\n      t.isListening = false;\n      t.monitorServer.stop(function(error) {\n        if (!error) {\n          // Disregard close exception\n          try {\n            server.close();\n          } catch (e) {}\n          t.trigger('stop');\n        }\n        return callback(error);\n      });\n    }\n  });\n\n  /**\n  * Constructor for a list of Server objects\n  *\n  *     var myList = new Server.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Server data model objects.\n  * @return {Backbone.Collection} Collection of Server data model objects\n  */\n  Server.List = Backbone.Collection.extend({model: Server});\n\n  /**\n  * Route application objects to their application site_db.\n  *\n  * This hooks FileSync.getFullPath to return the path to the object under the app DB\n  */\n  process.nextTick(function(){\n    var proto = Monitor.SyncProbe.FileSyncProbe.prototype;\n    proto.origGetFullPath = proto.getFullPath;\n    proto.getFullPath = function(modelId, callback) {\n      var t = this,\n          fullPath = null;\n\n      // Forward to the original version if not an app object\n      if (modelId.indexOf('/app/') !== 0) {\n        return t.origGetFullPath(modelId, callback);\n      }\n\n      // Process an /app/{appName} type modelId\n      var parts = modelId.split('/'),\n          appName = parts[2],\n          appDef = UI.Server.currentServer.apps[appName];\n\n      // No app with that name.  Use original path.\n      if (!appDef) {\n        return t.origGetFullPath(modelId, callback);\n      }\n\n      // Set a different dirPath & forward to the original method for processing\n      parts.splice(1,2); // remove app/{appName} from the modelId\n      var appModelId = parts.join('/');\n      t.dirPath = Path.join(appDef.moduleDir, 'site_db', t.get('className'));\n      return t.origGetFullPath(appModelId, callback);\n    };\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/TreeProbe.js":"// TreeProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('monitor'),\n      _ = Monitor._,\n      Backbone = Monitor.Backbone,\n      UI = Monitor.UI,\n      Tree = UI.Tree,\n      Probe = Monitor.Probe;\n\n  /**\n  * Abstract base class for a probe representing a node in a Tree\n  *\n  * The TreeView component, when used in conjunction with a TreeProbe\n  * can present a visual representation of the hierarchy in the browser.\n  *\n  * The *branches* and *leaves* elements of this probe represent the\n  * tree branches and leaves.  They must contain at least the *id*, but can\n  * also contain the optional *label* and *description* elements as well\n  * as any other metadata about the branch or leaf.\n  *\n  * Derived classes need only set the branches and leaves elements,\n  * and update as they detect changes.\n  *\n  * See the PagesProbe for an example implementation.\n  *\n  * @abstract\n  * @class TreeProbe\n  * @extends Probe\n  * @constructor\n  * @param [initParams] - Probe initialization parameters\n  *     @param [initParams.path=''] {String} Path to this node in the tree\n  */\n  var TreeProbe = Monitor.TreeProbe = Probe.extend({\n\n    // Set defaults\n    defaults: {\n      path:'',\n      leaves: [],\n      branches: []\n    },\n\n    /**\n    * Constructor initialization.\n    *\n    * @method initialize\n    */\n    initialize: function(attributes, options){\n      var t = this;\n\n      // Call parent constructor\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Turn leaves/branches into collections and forward changes to this model\n      UI.containedModel(t, 'leaves', Backbone.Collection);\n      UI.containedModel(t, 'branches', Backbone.Collection);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/PagesProbe.js":"// PagesProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('monitor'),\n      _ = Monitor._,\n      UI = Monitor.UI,\n      Path = require('path'),\n      FS = require('fs'),\n      TreeProbe = Monitor.TreeProbe,\n      FileProbe = Monitor.FileProbe;\n\n  // Define some constants\n  var CONST = {\n    objectClass: 'Page',\n    appLabel: 'App Pages',\n    appDescription: 'Application Pages'\n  };\n\n  /**\n  * This probe represents the pages and directories of a single\n  * node of the site.\n  *\n  * @class PagesProbe\n  * @extends TreeProbe\n  * @constructor\n  * @param [initParams] - Probe initialization parameters\n  *     @param [initParams.path=''] {String} Path to this node\n  */\n  var PagesProbe = Monitor.PagesProbe = TreeProbe.extend({\n\n    probeClass: 'PagesProbe',\n\n    /**\n    * Constructor initialization.\n    *\n    * @method initialize\n    */\n    initialize: function(attributes, options){\n      var t = this;\n      t.fileWatchers = {};\n\n      // Instance level constants (can be overridden in sub-classes)\n      t.CONST = t.CONST || CONST;\n\n      // Call parent constructor\n      TreeProbe.prototype.initialize.apply(t, arguments);\n\n      // Assume callback responsibility.\n      options.asyncInit = true;\n      var callback = options.callback;\n\n      // Set the root path from the Server's DB\n      t.rootPath = Path.join(UI.Server.currentServer.get('siteDbPath'), t.CONST.objectClass);\n\n      // Build the full path to the directory, possibly routed to an app DB\n      var path = t.get('path'),\n          parts = path.replace(/^[\\\\\\/]/,'').split('/'),\n          appName = parts[0] === 'app' ? parts[1] : null;\n      if (appName && UI.Server.currentServer.apps[appName]) {\n\n        // Build the dirPath from the module DB\n        var appDef = UI.Server.currentServer.apps[appName];\n        parts.splice(0,2);\n        t.dirPath = Path.join(appDef.moduleDir, 'site_db', t.CONST.objectClass, parts.join('/'));\n      }\n      else {\n\n        // Normal path - under the site_db/Page directory\n        t.dirPath = Path.join(t.rootPath, path);\n      }\n\n      // Go straight to sync (no stat/watch) if the path is the app directory\n      if (t.get('path') === '/app') {\n        return t.sync(callback);\n      }\n\n      // Watch the directory and synchronize objects in it.\n      // This is called after the FS.stat (below)\n      var watchSync = function() {\n        t.dirWatcher = FS.watch(t.dirPath, {persistent:false}, function(type){\n          t.sync();\n        });\n\n        // Synchronize this object with the directory.\n        t.sync(callback);\n      }\n\n      // Make sure the directory exists\n      FS.stat(t.dirPath, function(error, stat) {\n\n        // Create the directory if it doesn't exist\n        if (error && error.code == 'ENOENT') {\n          FileProbe.mkdir_r(t.dirPath, '0777', function(error) {\n            if (error) {\n              return callback(error);\n            }\n            // Created\n            return watchSync();\n          });\n          return;\n        }\n\n        // Other error than directory doesn't exist\n        if (error) {\n          return callback(error);\n        }\n\n        // This shouldn't happen\n        if (!stat.isDirectory()) {\n          return callback({err: 'Not a directory: ' + t.dirPath});\n        }\n\n        // Continue\n        return watchSync();\n      });\n    },\n\n    /**\n    * Release probe resources\n    */\n    release: function() {\n      var t = this;\n      if (t.dirWatcher) {\n        t.dirWatcher.close();\n        t.dirWatcher = null;\n      }\n      for (var pageId in t.fileWatchers) {\n        t.fileWatchers[pageId].close();\n      }\n      t.fileWatchers = {};\n    },\n\n    /**\n    * Synchronize the directory with this object\n    *\n    * @method sync\n    * @param callback {Function} Callback to call when complete\n    *     @param callback.error {Mixed} Set if anything goes wrong\n    */\n    sync: function(callback) {\n      var t = this,\n          dirs = [],\n          pages = [],\n          thisAppName = UI.Server.currentServer.thisAppName;\n      callback = callback || function(){};\n\n      // Synchronize the virtual /app directory\n      if (t.get('path') === '/app') {\n        for (var appName in UI.Server.currentServer.apps) {\n          // Don't add me to the /app directory if I'm an app\n          if (appName !== thisAppName) {\n            var app = UI.Server.currentServer.apps[appName];\n            dirs.push({\n              id: appName,\n              label: app.label || app.description || appName,\n              path: Path.join(app.moduleDir, 'site_db', t.CONST.objectClass)\n            });\n          }\n        }\n\n        // Trim directory branches that have no contents\n        t.trimDirs(dirs, function(error, trimmed) {\n          if (error) {\n            callback(error);\n          }\n          t.set({\n            leaves: pages,\n            branches: trimmed\n          });\n          return callback();\n        });\n        return;\n      }\n\n      // Get the directory at this level\n      FS.readdir(t.dirPath, function(error, fileNames) {\n\n        // Process errors\n        if (error) {\n          console.error('TreeProbe readdir error', error);\n          return callback(error);\n        }\n\n        // Don't show the main 404 page (it's too confusing)\n        if (t.CONST.objectClass === 'Page') {\n          fileNames = _.reject(fileNames, function(name){\n            return name === '404.json';\n          });\n        }\n\n        // Perform a stat on all files for meta-info\n        t.statFiles(fileNames, function(error, fileStats) {\n\n          // Process errors\n          if (error) {\n            console.error('TreeProbe statFiles error', error);\n            return callback(error);\n          }\n\n          // Process each file, recording directories and pages\n          for (var i = 0, l = fileStats.length; i < l; i++) {\n            var name = fileNames[i],\n                stat = fileStats[i],\n                id = Path.basename(name, '.json'),\n                page = {id:id};\n\n            if (stat.isDirectory()) {\n              page.path = Path.join(t.dirPath, name);\n              dirs.push(page);\n            }\n            else if (stat.isFile() && Path.extname(name).toLowerCase() === '.json') {\n              pages.push(page);\n            }\n            else {\n              console.error('Not a file or directory: ' + name);\n            }\n          }\n\n          // Read each page for the display label and description\n          t.readPages(pages, function(error) {\n\n            // Process errors\n            if (error) {\n              console.error('PagesProbe readPages error', error);\n              return callback(error);\n            }\n\n            // Add the virtual /app directory to the root\n            if (t.dirPath === t.rootPath) {\n              dirs.push({\n                id:'app',\n                label: t.CONST.appLabel,\n                description: t.CONST.appDescription,\n                path: Path.dirname(t.dirPath)\n              });\n            }\n\n            // Trim directory branches that have no contents\n            t.trimDirs(dirs, function(error, trimmed) {\n              if (error) {\n                callback(error);\n              }\n\n              t.set({\n                leaves: pages,\n                branches: trimmed\n              });\n              return callback();\n            });\n          });\n\n        });\n      });\n\n    },\n\n    /**\n    * Trim directories that have no content\n    *\n    * This accepts an array of objects, where each object must have a 'path' element.\n    * If no content is at the path, the object will be trimmed from the array.\n    *\n    * The path element will be removed after checking.\n    *\n    * @method trimDirs\n    * @param dirs {Object} An object that contains a 'path' element\n    * @param callback {function(error, trimmed)} Called when complete (or error)\n    */\n    trimDirs: function(dirs, callback) {\n      var t = this,\n          numLeft = dirs.length,\n          fileRegexp = /.json$/,\n          trimmed = [];\n\n      // Already trimmed\n      if (numLeft === 0) {\n        return callback(null, dirs);\n      }\n\n      // Process each directory\n      dirs.forEach(function(dir) {\n        t.hasContents(dir.path, fileRegexp, function(error, hasContents) {\n          if (error) {\n            numLeft = 0;\n            return callback(error);\n          }\n          delete dir.path;\n          if (hasContents) {\n            trimmed.push(dir);\n          }\n          if (--numLeft === 0) {\n            return callback(null, trimmed);\n          }\n        });\n      });\n    },\n\n\n    /**\n    * Determine if a directory has any contents.\n    *\n    * This will return true if any sub-directories with contents exist, or\n    * if any files with the specified RegExp exist.\n    *\n    * @method hasContents\n    * @param dirname {Path} Full path to the directory\n    * @param fileRegexp {RegExp} Regular expression to test for files\n    * @param callback {function(error, hasContents}} Regular expression to test for files\n    */\n    hasContents: function(dirname, fileRegexp, callback) {\n      var t = this;\n\n      // Get the directory at this level\n      FS.readdir(dirname, function(error, fileNames) {\n\n        // Process errors\n        if (error) {\n          console.error('Read dir error', error);\n          return callback(error);\n        }\n\n        // Process sequentially until content is found.\n        // If parallel, a deep scan would occur every time.\n        var dirsToCheck = [];\n        function checkNext() {\n\n          // Done checking all filenames\n          if (fileNames.length === 0) {\n\n            // Check directories, and return true if any have content\n            t.trimDirs(dirsToCheck, function(error, trimmed) {\n              return callback(error, trimmed.length > 0);\n            });\n            return;\n          }\n\n          // Stat the next entry\n          var filename = fileNames[0];\n          fileNames.splice(0,1);\n          var pathName = Path.join(dirname, filename);\n          FS.stat(pathName, function(error, stat) {\n            if (error) {\n              return callback(error);\n            }\n\n            // Check for directory content or if a file should be included\n            if (stat.isDirectory()) {\n              dirsToCheck.push({path:pathName});\n            }\n            else {\n              // There is content if a file exists and it matches an optional regexp\n              if (!fileRegexp || fileRegexp.test(filename)) {\n                return callback(null, true);\n              }\n            }\n\n            // Check the next filename\n            checkNext();\n          });\n        }\n\n        // Kick off the first check\n        checkNext();\n      });\n    },\n\n    /**\n    * Stat all the files, returning an array of file stats matching the\n    * array of input files.\n    *\n    * @method statFiles\n    * @param fileNames {Array} An array of filenames to stat (from this directory)\n    * @param callback {Function(error, stats)}\n    *     @param callback.error {Mixed} Set if an error occured\n    *     @param callback.stats {Array of Stat} An array of fs.stats objects\n    */\n    statFiles: function(fileNames, callback) {\n      var t = this,\n          stats = [],\n          didError = false,\n          numLeft = fileNames.length;\n\n      // No files to process\n      if (fileNames.length === 0) {\n        return callback(null, stats);\n      }\n\n      // Call stat on each file\n      fileNames.forEach(function(fileName, index) {\n        var fullPath = Path.join(t.dirPath, fileName);\n        FS.stat(fullPath, function(error, stat) {\n\n          // Process a stat error\n          if (error) {\n            didError = true;\n            return callback(error);\n          }\n\n          // Do nothing if a prior error callback happened\n          if (didError) {\n            return;\n          }\n\n          // Set this stat item\n          stats[index] = stat;\n\n          // Callback if all stats are complete\n          if (--numLeft === 0) {\n            callback(null, stats);\n          }\n        });\n      });\n\n    },\n\n    /**\n    * Add title (label) and description to the specified page objects.\n    *\n    * @method readPages\n    * @param pages {Array of Object} An array of objects with the id element set\n    * @param callback {Function(error)}\n    */\n    readPages: function(pages, callback) {\n      var t = this,\n          didError = false,\n          numLeft = pages.length;\n\n      // Callback early if no pages to read\n      if (pages.length === 0) {\n        return callback();\n      }\n\n      // Read and parse each file for the title/description\n      pages.forEach(function(page, index) {\n\n        // Read the file\n        var fullPath = Path.join(t.dirPath, page.id + '.json');\n        FS.readFile(fullPath, 'utf8', function(error, file) {\n\n          // Process a stat error\n          if (error) {\n            didError = true;\n            return callback(error);\n          }\n\n          // Parse the JSON\n          var parsed = null;\n          try {\n            parsed = JSON.parse(file);\n          }\n          catch (e) {\n            didError = true;\n            console.error('JSON error parsing page: ' + fullPath, e);\n            return callback(e);\n          }\n\n          // Do nothing if a prior error callback happened\n          if (didError) {\n            return;\n          }\n\n          // Set the page title and description\n          if (parsed.title) {\n            page.label = parsed.title;\n          }\n          if (parsed.description) {\n            page.description = parsed.description;\n          }\n\n          // Add a file watcher if not already watching\n          if (!t.fileWatchers[page.id]) {\n            t.fileWatchers[page.id] = new FS.watch(fullPath, {persistent:false}, function(type){\n              t.sync();\n            });\n          }\n\n          // Callback if all page reads are complete\n          if (--numLeft === 0) {\n            callback(null);\n          }\n        });\n      });\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/lib/js/ToursProbe.js":"// ToursProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://github.com/lorenwest/monitor-dashboard\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('monitor'),\n      PagesProbe = Monitor.PagesProbe;\n\n  // Define some constants\n  var CONST = {\n    objectClass: 'Tour',\n    appLabel: 'App Tours',\n    appDescription: 'Application Tours'\n  };\n\n  /**\n  * This probe represents the list of tours available on the site\n  *\n  * @class ToursProbe\n  * @extends TreeProbe\n  * @constructor\n  * @param [initParams] - Probe initialization parameters\n  *     @param [initParams.path=''] {String} Path to this node\n  */\n  var ToursProbe = Monitor.ToursProbe = PagesProbe.extend({\n\n    probeClass: 'ToursProbe',\n\n    /**\n    * Constructor initialization.\n    *\n    * @method initialize\n    */\n    initialize: function(attributes, options){\n      var t = this;\n\n      // Override instance level constants\n      t.CONST = CONST;\n\n      // This is the same as a PagesProbe except for the constants (above)\n      PagesProbe.prototype.initialize.apply(t, arguments);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor-dashboard/node_modules/monitor-dashboard/config/default.js":"// Default configurations\nmodule.exports = {\n\n  // Overrides from the monitor package\n  Monitor: {\n    appName: 'MonitorDashboard',\n    consoleLogListener: {\n      pattern: \"{trace,warn,error,fatal}.*\"\n    }\n\n  },\n\n  // Dashboard application configurations\n  Dashboard: {\n\n    // The port to listen on for application traffic\n    port:4200,\n\n    // Only allow connections from this machine by default.  This reduces\n    // accidental security breaches by requiring you to consider your network\n    // security policies before allowing external connections.\n    // See the external.js file in this directory for more information.\n    allowExternalConnections: false,\n\n    // Path to the site database.  Paths that start with '.' are relative\n    // to process.cwd(), which is usually the application root directory.\n    siteDbPath: './site_db'\n  }\n\n}\n"}